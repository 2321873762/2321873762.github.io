



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="主人" href="http://example.com/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="主人" href="http://example.com/atom.xml" />
<link rel="alternate" type="application/json" title="主人" href="http://example.com/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="总结" />


<link rel="canonical" href="http://example.com/2100/03/09/%E9%9D%A2%E8%AF%95%E9%AB%98%E5%87%A0%E7%8E%87%E8%80%83%E7%9A%84%E9%A2%98/">



  <title>
面试高几率考的题 - 总结 |
GX = 主人 = 前端工程师</title>
<meta name="generator" content="Hexo 5.2.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">面试高几率考的题
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2100-03-09 19:11:58">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2100-03-09T19:11:58+08:00">2100-03-09</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">GX</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giph4lm9i7j20zk0m84qp.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipey84bjtj20zk0m8hdt.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeubcbajj20zk0m8h1h.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclga70tsj20zk0m84mr.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipew28b65j20zk0m8hdt.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giciuv0socj20zk0m8qes.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E6%80%BB%E7%BB%93/" itemprop="item" rel="index" title="分类于 总结"><span itemprop="name">总结</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="http://example.com/2100/03/09/%E9%9D%A2%E8%AF%95%E9%AB%98%E5%87%A0%E7%8E%87%E8%80%83%E7%9A%84%E9%A2%98/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="高祥">
    <meta itemprop="description" content="前端工程师, 前端高级工程师欢迎你">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="主人">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h2 id="1响应式布局如何实现"><a class="markdownIt-Anchor" href="#1响应式布局如何实现">#</a> 1. 响应式布局如何实现</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   为什么要使用响应式布局:</span><br><span class="line">在之前使用固定宽高有一定的局限：屏幕越来越宽时，因为定得宽是固定的，这样会让页面不美观</span><br><span class="line">			     屏幕越来越小时，因为定宽的局限会让用户看不到完整的页面内容</span><br><span class="line">在这种情况下，响应式布局就出现了</span><br><span class="line">   响应式布局的实现(有五种方法)</span><br><span class="line"><span class="number">1.</span>百分比布局：百分比布局是相对于父元素进行布局，百分比能够对width,height,padding,margin来进行布局，border,font-size不能；</span><br><span class="line">             局限： 因为百分比布局只能对大面积的地方进行布局，所以不够完美  <span class="number">2.</span>css3媒体查询：媒体查询可以根据不同的分辨率来设置不同的css样式，通过这种方式来适配不同屏幕,相比于百分比布局，媒体查询可以对布</span><br><span class="line">	          局进行更细致的调整</span><br><span class="line">	          @media screen and(min-width:1200px)  @media screen and(max-width:1200px) Screen就是客户端屏幕的信息</span><br><span class="line">	局限：媒体查询在设置的时候需要在每个分辨率和操作下设置不同的css样式</span><br><span class="line"><span class="number">3.</span>rem响应式布局：rem是一个单位，跟px,em类似，1rem就等于html的font-size值，有两种方法可以进行设置</span><br><span class="line">	<span class="number">1.</span>通过媒体查询来设置，在不同的分辨率下给html的font-size赋值；比较麻烦</span><br><span class="line">	<span class="number">2.</span>js进行动态计算给font-size设置值：封装一个函数：通过屏幕的宽度去处理某个数，得出来的值就是html的font-size值，当屏幕宽</span><br><span class="line">				      度改变的时候就调用这个函数，这样在使用rem的时候就会根据html的font-size来进行等比缩放；</span><br><span class="line"><span class="number">4.</span>弹性盒子布局：通过display:flex;来布局，给父元素设置display:flex;在给子元素设置想要改变的属性；</span><br><span class="line"><span class="number">5.</span>vw响应式布局：vw是基于视口的布局方案，所以在使用的时候需要在meta标签的视口中声明；1vw等于视口宽度的<span class="number">1</span>%  1vh等于视口高度的<span class="number">1</span>%；</span><br><span class="line">     现在用的都是vw，因为高度是根据内容的多少而自适应的。</span><br></pre></td></tr></table></figure>
<h2 id="2rem布局原理"><a class="markdownIt-Anchor" href="#2rem布局原理">#</a> 2.rem 布局原理</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原理：rem是指相对于根元素的字体大小的单位，是基于根元素的font-size值来进行计算，就是1rem就等于html的font-size值；1rem等于多少px,就是font-size的值*</span><br><span class="line">          你设定的rem的值；</span><br><span class="line">怎么使用rem来布局</span><br><span class="line">	使用Js来动态修改根元素的font-size值，当屏幕宽度发生改变的时候rem就会被动态计算出来，那你设置的rem就会自动转换为px单位；</span><br><span class="line">	JS代码：<span class="function"><span class="keyword">function</span> <span class="title">rem</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	          	<span class="built_in">document</span>.documentElement.style.fontSize=<span class="built_in">document</span>.documentElement.clientWidth/<span class="number">7.5</span>+<span class="string">&#x27;px&#x27;</span></span><br><span class="line">	            &#125;</span><br><span class="line">	            rem()</span><br><span class="line">               <span class="built_in">window</span>.onresize=rem;</span><br><span class="line">           </span><br></pre></td></tr></table></figure>
<h2 id="3数据类型判断"><a class="markdownIt-Anchor" href="#3数据类型判断">#</a> 3. 数据类型判断</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一共有<span class="number">4</span>中数据类型判断的方法</span><br><span class="line"><span class="number">1.</span><span class="keyword">typeof</span>()他可以检测一些普通数据类型，比较直观的数据，比如number,string这些能够具体的检测出来他们的类型，判断引用数据类型无论引用的对象是什么类型都返回object；</span><br><span class="line"><span class="number">2.</span><span class="keyword">instanceof</span> 他可以检测引用数据类型，可以判断一个变量是否是某个类型和是否是某个实例，由构造类型判断数据类型，返回的是<span class="literal">true</span>或者<span class="literal">false</span>,不可以判断<span class="literal">null</span>和<span class="literal">undefined</span>    fn <span class="keyword">instanceof</span> Fn</span><br><span class="line"><span class="number">3.</span><span class="title">constructor</span> 他是通过对象的<span class="title">construnctor</span>直接来判断他是否和他的原型相同，但是一旦构造函数的原型被更改那么这个方法就不好用了   <span class="title">fn</span>.<span class="title">constructor</span> == <span class="title">Array</span></span><br><span class="line">4.<span class="title">Object</span>.<span class="title">prototype</span>.<span class="title">toString</span>.<span class="title">call</span>(<span class="params"></span>) 他目前是一个最完美的解决方案，他只需要在括号里边写你想要判断的数据类型就行了，他可以直接从原型里面找要判断的类型</span><br></pre></td></tr></table></figure>
<h2 id="4原型和原型链"><a class="markdownIt-Anchor" href="#4原型和原型链">#</a> 4. 原型和原型链</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数原型：每个函数都有一个prototype对象，这个对象就是函数的原型，每个函数原型中都有一个<span class="title">constructor</span>属性，就是构造函数本身，</span><br><span class="line">          构造函数被实例化后，包含一个<span class="title">__proto__</span>属性，这个属性就是函数的原型，<span class="title">new</span>实例化后的对象没有<span class="title">prototype</span>原型，有<span class="title">__proto__</span>;</span><br><span class="line">          函数的原型有一个优点就是在原型中添加属性，所有的实例化对象都可以访问到</span><br><span class="line">原型链：在访问一个属性或者方法的时候，先从自身里面去找，如果自身找不到就通过这个对象的proto属性指向的对象查找，如果还没有</span><br><span class="line">	就继续通过现在查找的对象的proto属性指向的对象查找，直到结束，如果最后找不到就返回<span class="literal">undefined</span>；</span><br><span class="line">代码实现：先定义一个函数，里面写一些属性；然后在这个函数的原型上设置一些属性；然后在<span class="keyword">new</span> 实例化这个函数；最后通过调用这个实例化出来的新函数来查找属性，就可以实现一个原型链；</span><br></pre></td></tr></table></figure>
<h2 id="5闭包"><a class="markdownIt-Anchor" href="#5闭包">#</a> 5. 闭包</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">要了解闭包，先得了解变量的作用域，分为全局作用域和局部作用域，JS中函数内部可以访问函数外部的变量，但函数外部却无法访问函数内部</span><br><span class="line">的变量；</span><br><span class="line">闭包就是能够访问其他函数内部的变量的函数，闭包的本质就是把函数内部和外部连接起来；</span><br><span class="line">闭包有一个封闭性的特点：就是一旦形成闭包，那么外界就无法访问到闭包里面的数据q</span><br><span class="line">闭包的优缺点</span><br><span class="line">	优点：可以模仿块级作用域，把变量保存在内存中，防止全局变量污染，就是减少创建全局变量，减少传递给函数的参数量；</span><br><span class="line">	缺点：虽然说防止了全局变量污染，但是这样容易导致内存泄漏，会让使用过的变量无法回收，一直占着内存；</span><br><span class="line">应用场景：<span class="number">1.</span>SetTimeout：原生的<span class="built_in">setTimeout</span>传递的函数不能带参数，通过闭包可以实现传参效果。</span><br><span class="line">	 <span class="number">2.</span>回调：定义一个行为，然后把它关联到某个用户事件上。代码通常会作为一个回调绑定到事件上；</span><br></pre></td></tr></table></figure>
<h2 id="6js继承"><a class="markdownIt-Anchor" href="#6js继承">#</a> 6.js 继承</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">	BOM：浏览器对象模型；DOM：文档对象模型；</span><br><span class="line">	<span class="number">1.</span>构造函数继承：构造函数继承的中心思想就是把父函数的<span class="built_in">this</span>指向改为子函数的<span class="built_in">this</span>指向，从而实现继承；</span><br><span class="line">		优点：可以传递参数，借助call等改变<span class="built_in">this</span>指向的方法；</span><br><span class="line">		改变<span class="built_in">this</span>指向的方法：call 第二个参数与要改变指向中的方法的参数对应</span><br><span class="line">				apply 第二个参数是一个数组,数组中的元素与要改变的方法中的参数对应</span><br><span class="line">				bind方法使用后返回的是一个函数,所以第二个参数要在()里写,调用</span><br><span class="line">		缺点：他只能继承父函数本身的属性，父类原型的方法却不能使用；无法实现构造函数的复用。每个新实例都有父类构造函数的副本</span><br><span class="line">	<span class="number">2.</span>原型链继承：原型链继承就是把子函数的原型改为父函数的实例，从而实现继承</span><br><span class="line">		优点：子类可以继承父类和父类原型中的属性和方法；</span><br><span class="line">		缺点：子类无法在继承的过程中给父类传递参数，因为子类的原型都是New Parent,所以实例化出来的对象都是一样的，</span><br><span class="line">		          而且Parent上面的引用类型只要有一个实例对象修改了，其他实例对象也会跟着修改，因为他们的原型对象都是</span><br><span class="line">		          共用的。</span><br><span class="line">	<span class="number">3.</span>组合式继承：组合式继承就是把构造函数继承和原型链继承结合起来，从而实现继承；</span><br><span class="line">		优点：他使用原型链实现对原型属性和方法的继承，又通过借用构造函数来实现对实例属性的继承。这样既通过在原型</span><br><span class="line">		          上定义方法实现了函数复用，又保证每个实例都有他自己的属性。</span><br><span class="line">		缺点：在使用组合式继承的过程中父类的原型对象被调用了两次，这个是没有必要的，而且子类实例的构造函数是来自父类；</span><br><span class="line">	<span class="number">4.</span>原型式继承：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。</span><br><span class="line">		特点：类似于复制一个对象，用函数来包装。</span><br><span class="line">		缺点：<span class="number">1.</span>所有实例都会继承原型上的属性。<span class="number">2.</span>无法实现复用。（新实例属性都是后面添加的）</span><br><span class="line">	<span class="number">5.</span>寄生式继承：就是给原型式继承外面套了个壳子。</span><br><span class="line">		优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。</span><br><span class="line">		缺点：没用到原型，无法复用。</span><br><span class="line">	<span class="number">6.</span>寄生组合式继承：在寄生式继承的基础上,将父类的原型传入包裹函数中，然后定义子类的构造函数，并在子类的构造函数中调用父类的构造函数，</span><br><span class="line">			然后生成子类的对象，修改子类的构造函数属性，实现理想的继承</span><br><span class="line">		优点：效率高  原型链保持不变</span><br><span class="line"><span class="string">``</span><span class="string">`		</span></span><br><span class="line"><span class="string">## 7.时间冒泡和事件捕获</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">	事件类型：有键盘事件，鼠标事件，表单事件</span><br><span class="line">	事件：JS和HTML之间的交互是通过事件实现的，事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。</span><br><span class="line">	事件流：	事件流描述的是页面中接收事件的顺序</span><br><span class="line">	<span class="number">1.</span>事件冒泡：就是事件开始时由嵌套最深的元素接收，然后逐级向上传播到最外面的那个节点；</span><br><span class="line">	   阻止冒泡：<span class="number">1.</span>js中的event.stopPropagation() <span class="number">2.</span>vue修饰符 .stop 加到你想要阻止冒泡的点击事件后面</span><br><span class="line">	<span class="number">2.</span>阻止默认行为：<span class="number">1.</span>js中的event.preventDefault() <span class="number">2.</span>vue中的.prevent</span><br><span class="line">	<span class="number">3.</span>事件捕获：由嵌套最外面的节点先触发事件，最后是嵌套最深的节点触发事件</span><br><span class="line">	  设置事件捕获：<span class="number">1.</span>js中addEventListener(事件名字,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="literal">true</span>/<span class="literal">false</span>);<span class="literal">true</span>和<span class="literal">false</span>如果在未指定的情况下，默认为<span class="literal">false</span>，向上冒泡的</span><br><span class="line">		         事件不会触发；</span><br><span class="line">		         <span class="number">2.</span> .captrue 在定义的事件后面写click.captrue</span><br><span class="line">	<span class="number">3.</span>事件委托：利用事件冒泡的原理，指定某一个事件程序来管理某一类型的所有事件；比如子元素的事件交由父元素进行处理；</span><br><span class="line">		写法：jq:$(<span class="string">&quot;#ul&quot;</span>).on(<span class="string">&quot;click&quot;</span>,<span class="string">&#x27;li&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;     js:ul.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    	      $(<span class="built_in">this</span>);			<span class="keyword">var</span> event = event || <span class="built_in">window</span>.event;</span><br><span class="line">               		 &#125;)				<span class="keyword">var</span> target = event.target || event.srcElement;</span><br><span class="line">						&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8h5和css3的新特性"><a class="markdownIt-Anchor" href="#8h5和css3的新特性">#</a> 8.h5 和 css3 的新特性</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">h5:<span class="number">1.</span> 用于绘画 canvas 元素；<span class="number">2.</span>用于播放视频的 video 和 audio 元素；</span><br><span class="line">     <span class="number">3.</span> 本地离线存储 <span class="built_in">localStorage</span> 长期存度储数据，浏览器关闭知后数据不丢失；sessionStorage 的数据在浏览器关闭后自动删除。</span><br><span class="line">     <span class="number">4.</span>增加语义化的标签：比如article、footer、header、nav、section</span><br><span class="line">     <span class="number">5.</span>表单控件：date、time、email、url、search等；</span><br><span class="line">css3：选择器、渐变background-image: linear-gradient线性渐变、radial-gradient径向渐变</span><br><span class="line">	变形box-shadow: 2px 2px 2px #000;</span><br><span class="line">过渡动画transition： all默认值，所有属性都将获得过渡效果，none：没有属性会获得过渡效果， transition-duration：定义过渡效果花费的时间</span><br><span class="line">	transform属性： translate(x,y) 根据X轴和Y轴位置给定的参数，从当前元素位置移动，scale(*x*,*y*)：改变元素的宽度和高度，rotate(*angle*)：在参数中规定角度 旋转角度</span><br><span class="line">盒子模型、flex弹性布局、媒体查询@media;</span><br></pre></td></tr></table></figure>
<h2 id="9sessionstoragelocalstoragecookie-的区别"><a class="markdownIt-Anchor" href="#9sessionstoragelocalstoragecookie-的区别">#</a> 9.SessionStorage，LocalStorage，Cookie 的区别</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">他们都是保存在浏览器端，而且是同源的</span><br><span class="line">LocalStorage：生命周期是永久的，关闭页面或浏览器之后<span class="built_in">localStorage</span>中的数据也不会消失。就是除非主动删除数据，否则的话数据</span><br><span class="line">	        永远不会消失；不参与和浏览器的通信，大小为5M</span><br><span class="line">方法：LocalStorage.getItem(),setItem(),removeItem(),clear();</span><br><span class="line">SessionStorage:生命周期是只在当前浏览器窗口中有效，SessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没</span><br><span class="line">	         有关闭，即使刷新页面或者进入同源的另一个页面，数据也还在。但是SessionStorage在关闭了浏览器数据就会销毁。</span><br><span class="line">方法：SessionStorage.getItem(),setItem(),removeItem(),clear();</span><br><span class="line">Cookie：生命周期只在设置的cookie过期时间之前有效,存放数据一般为4K左右，一般数量不能超过<span class="number">20</span>个，cookie可以与服务端进行通</span><br><span class="line">	信，但是使用cookie保存过多数据会带来性能问题。而且cookie需要自己封装。总之cookie就是一个存放数据的东西，存放</span><br><span class="line">	客户端和应用设备上。</span><br><span class="line">应用场景：用户注册，用户登录，购物车等</span><br><span class="line">cookie的参数：name,value,域名,路径，是否是http,是否是https</span><br><span class="line">cookie的操作</span><br><span class="line">	<span class="built_in">document</span>.cookie = <span class="string">&quot;username=sorber&quot;</span> name名字</span><br><span class="line">	<span class="built_in">document</span>.cookie  获取cookie的内容</span><br></pre></td></tr></table></figure>
<h2 id="10什么是深拷贝和浅拷贝如何实现"><a class="markdownIt-Anchor" href="#10什么是深拷贝和浅拷贝如何实现">#</a> 10. 什么是深拷贝和浅拷贝，如何实现</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">深拷贝与浅拷贝都是针对与引用数据类型来说的；   </span><br><span class="line">浅拷贝只复制一层对象的属性，值引用；应用场景就是：对于只有一层结构的<span class="built_in">Array</span>，<span class="built_in">Object</span>想要拷贝一个副本时使用；</span><br><span class="line">实现方式：<span class="number">1.</span>使用<span class="built_in">Object</span>.assign(&#123;&#125;,obj)第一个参数是一个空对象，第二个参数是你要复制的对象；通过这个方法我们知道浅拷贝不能修改基础的数据类型，可以修改引用的数据类型；</span><br><span class="line">	<span class="number">2.</span>ES6中的...扩展运算符来进行浅拷贝的实现；</span><br><span class="line">深拷贝就是递归复制了所有的层级和地址引用。就是拷贝多层，每一级别的数据都会别拷贝出来；应用场景就是复制深层次的object的数据结构；</span><br><span class="line">实现方式：<span class="number">1.</span>利用<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))；就是先将这个对象转换为字符串，再将字符串转换为一个对象，这样就实现了一个深拷贝的原理；</span><br><span class="line">	<span class="number">2.</span>通过定义一个函数deep来实现，他的参数是一个obj对象，函数里面第一步先判断参数obj是否为一个对象，如果不是就返回<span class="keyword">return</span> <span class="literal">false</span>；如果是的话就定义一个空的数组作为存储空间；</span><br><span class="line">	随后在遍历obj,如果内容是一个对象的话就把循环的当前项添加到上面创建的新数组中；最后在返回这数组；然后要是需要进行深拷贝的话就调用这个函数；</span><br></pre></td></tr></table></figure>
<h2 id="11解构赋值"><a class="markdownIt-Anchor" href="#11解构赋值">#</a> 11. 解构赋值</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解构赋值语法是一种Javascript表达式。通过解构赋值，可以将属性/值从对象/数组中取出，赋值给其他变量。是Es6中的新语法，他的本质是模式匹配，就是</span><br><span class="line">只要等号两边的模式相同，左边的变量就会被赋予匹配的右边的值，要是匹配不成功变量的值就是<span class="literal">undefined</span>；他是针对数组或者对象进行模式匹配，然后对</span><br><span class="line">其中的变量进行赋值；他左边表示的是要解构的目标，右边表示解构源；解构赋值还是对赋值运算符的扩展；</span><br><span class="line">应用场景：<span class="number">1.</span>交换变量的值；<span class="number">2.</span>让函数中返回多个值，函数只能返回一个值，但用解构赋值的话可以返回是一个数组或者对象；<span class="number">3.</span>函数参数的定义；</span><br><span class="line">	<span class="number">4.</span>提取json数据</span><br></pre></td></tr></table></figure>
<h2 id="12es6有哪些新扩展"><a class="markdownIt-Anchor" href="#12es6有哪些新扩展">#</a> 12.ES6 有哪些新扩展</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>新增了<span class="keyword">let</span>和<span class="keyword">const</span>两个块级作用域;和<span class="keyword">var</span>一样都是定义变量的关键字，<span class="keyword">var</span>是es5里面的；<span class="keyword">let</span>和<span class="keyword">const</span>是es6里面的；</span><br><span class="line">	区别：<span class="keyword">let</span>声明的变量不可以自动提升;<span class="keyword">var</span>声明的可以自动提升；<span class="keyword">let</span>不允许在相同作用域里，重复声明一个变量，<span class="keyword">var</span>可以；</span><br><span class="line">	          <span class="keyword">let</span>允许块级作用域的任意嵌套，外层无法读取内层作用域的变量，<span class="keyword">var</span>可以；<span class="keyword">let</span>声明的作用域只在当前代码块的&#123;&#125;内有效,<span class="keyword">let</span>可以解决<span class="keyword">for</span>循环i全局变量污染的问题；</span><br><span class="line">	          <span class="keyword">const</span>声明的是一个只可以读的常量。只要声明，常量的值就不可以改变。他和<span class="keyword">let</span>一样<span class="keyword">const</span>也是一个块级作用域，无法变量提升，重复声明</span><br><span class="line"><span class="number">2.</span>新增了箭头函数</span><br><span class="line">	箭头函数和普通函数的不同：他们的写法不同；<span class="built_in">this</span>指向不同：箭头函数指向的是定义时的对象，普通函数是指向调用它的对象;</span><br><span class="line">			            箭头函数不可以当作构造函数，就是不可以使用<span class="keyword">new</span>命令，否则报错；箭头函数没有<span class="built_in">arguments</span>对象，得到的是外层函数的参数；</span><br><span class="line">	</span><br><span class="line">	总结：箭头函数，最开始就是为了解决<span class="built_in">this</span>指向问题，箭头函数里面的<span class="built_in">this</span>是定义的时候确定的，<span class="built_in">this</span>一旦确定无法改变，箭头函数最好的就是简洁；</span><br><span class="line">	          同时箭头函数一定是匿名函数，箭头函数适合于没有复杂逻辑和无副作用的纯函数场景下,比如map,filter的回调函数中；</span><br><span class="line">	          最好不要在最外层定义箭头函数，因为在函数内部操作<span class="built_in">this</span>会容易污染全局作用域。在箭头函数外部包一层普通函数，可以将<span class="built_in">this</span>控制在可见范围内；</span><br><span class="line"><span class="number">3.</span>增加了解构赋值</span><br><span class="line"><span class="number">4.</span>模板字符串</span><br><span class="line">	传统的输出模板特别繁琐，而且容易拼接错误</span><br><span class="line">	ES6中的模板字符串是增强版的字符串，用反引号<span class="string">``</span>，标识，它可以当做普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量；</span><br><span class="line">	模板字符串里还可以<span class="number">2</span>放入花括号，在花括号里边可以写入任意JS表达式，还可以引用对象属性。而且模板字符串还可以调用函数；</span><br><span class="line"><span class="number">5.</span>ES6还新增了<span class="built_in">Set</span>和<span class="built_in">Map</span>数据结构</span><br><span class="line">	<span class="built_in">Set</span>对象他类似于数组，且成员的值都是唯一的。他常见的方法有<span class="number">5</span>种：add():添加某个值然后返回<span class="built_in">Set</span>结构本身。size()返回<span class="built_in">Set</span>实例的成员总数；</span><br><span class="line">	   <span class="keyword">delete</span>()删除某个值，返回一个布尔值，表示是否删除成功；has()返回一个布尔值，表示该值是否为<span class="built_in">Set</span>的成员。clear()清除所有成员，没有返回值；</span><br><span class="line">	   <span class="built_in">Set</span>集合中的数据不允许有重复，可以做数组去重<span class="number">1.</span>(...new set(arr))  <span class="number">2.</span>arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> set.add(item));</span><br><span class="line">	<span class="built_in">Map</span>对象是键值对集合，和<span class="built_in">JSON</span>对象类似，但是key不仅可以是字符串还可以是对象；</span><br><span class="line">	<span class="built_in">Map</span>常见的方法也有<span class="number">5</span>种：map.set()可以获取对象的属性；get()可以获取对象的name属性；size()获取元素的存储数；has()可以知道指定元素是否</span><br><span class="line">	   存在；<span class="keyword">delete</span>()可以删除指定属性</span><br><span class="line"><span class="number">6.</span>把<span class="keyword">for</span>循环改为<span class="keyword">for</span> <span class="keyword">of</span>循环</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">in</span>是es5的标准，用来遍历Key值，遍历对象和数组，<span class="keyword">for</span> <span class="keyword">of</span>是es6的标准，用来遍历value值，遍历数组，不能遍历普通对象；</span><br><span class="line">	因为普通对象没有symbol属性，如果对象拥有symbol属性，就可以使用<span class="keyword">for</span> <span class="keyword">of</span>遍历；</span><br><span class="line">	symbol是es6新增的一种基本数据类型，他是一个独一无二的数据类型，在es5中对象属性名字都是字符串容易造成属性名冲突，为了避免这种情况</span><br><span class="line">	Es6就引入了symbol类型，<span class="built_in">Symbol</span>值能够作为对象属性的标识符；</span><br><span class="line">	使用<span class="keyword">for</span> <span class="keyword">in</span>会遍历数组所有的可枚举属性，包括原型，所以<span class="keyword">for</span> <span class="keyword">in</span>更适合遍历对象；</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">in</span>遍历的是数组的索引,<span class="keyword">for</span> <span class="keyword">of</span>遍历的是数组的元素值</span><br><span class="line"><span class="number">7.</span>Es6新增了模块化</span><br><span class="line">	在Es6之前是JavaScript是没有模块系统的，那么他就无法将一个大程序拆分成若干个互相依赖的小文件；如果需要进行模块化操作，就需要从第三方引入；</span><br><span class="line">	在ES6中就提供了模块化，才让JavaScript第一次支持了<span class="built_in">module</span>。ES6的模块化分为导出(<span class="keyword">export</span>)和导入(<span class="keyword">import</span>)两个模块；</span><br><span class="line">	模块可以理解为和函数代码块一样的功能，是封装对象的属性和方法的JavaScript代码，他可以是某单个文件，变量或者函数</span><br><span class="line">	而且引入模块和引入脚本是有区别的，前者更多的是按需引入加载，后者是无论使用还是不使用，全部一次性引入和加载，类似于通过script标签引入Jquery等，这些都是一次性引入的；</span><br><span class="line">	导出：Es6模块导出分为默认导出和指定导出，默认导出的话可以用任意名字来接收，比如导出的是<span class="keyword">export</span> <span class="keyword">default</span> module1; 接收的时候可以 <span class="keyword">import</span> x，</span><br><span class="line">	如果要一次导出多个，需要用&#123;&#125;包裹，接收时必须与导出时同名 </span><br><span class="line">	接收：接收用<span class="keyword">import</span> &#123;name,age&#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line">	在导出中除了<span class="keyword">export</span>关键字，每一个声明必须和脚本中的一样，因为导出的函数和声明需要有一个名称；</span><br><span class="line">	导出数据，只需要在里边写上数据名就可以<span class="keyword">export</span> &#123;name,age&#125; 导出函数只需要你定义好函数，然后把函数名导出就可以<span class="keyword">export</span> sum;</span><br><span class="line"><span class="number">8.</span>    (...)扩展运算符：用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</span><br><span class="line"><span class="number">9.</span>新增了<span class="built_in">Promise</span>关键字</span><br></pre></td></tr></table></figure>
<h2 id="13promise是什么有哪些状态和参数如何使用"><a class="markdownIt-Anchor" href="#13promise是什么有哪些状态和参数如何使用">#</a> 13.promise 是什么？有哪些状态和参数？如何使用？</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>是什么？</span><br><span class="line">	<span class="built_in">Promise</span>是异步编程的一种解决方案，从语法上讲，promise是一个对象，通过他可以获取异步操作的消息；<span class="built_in">Promise</span>是一个内置的构造函数，他是通过<span class="keyword">new</span> <span class="built_in">Promise</span>来操作；</span><br><span class="line">	<span class="built_in">Promise</span>其实就是一个方法，一个JS甚至是一个页面的后续JS代码的执行，因为他们都依赖于异步返回的数据，基于这个数据进行操作；</span><br><span class="line">为什么会有<span class="built_in">Promise</span>？</span><br><span class="line">	在ES5中处理异步，基本都是选择回调函数的请求方式，在请求到的成功回调函数里面继续写函数，长期就形成了回调地狱；在需要的操作少的时候</span><br><span class="line">	是可以接受的，但是在需要多个操作的时候，会导致多个回调函数嵌套，导致代码不够直观，且难以维护；所以就出现了<span class="built_in">Promise</span>最初就为了解决回调地狱的问题；</span><br><span class="line">	他采用链式调用的方式并且代码比较简洁明了且容易维护。</span><br><span class="line"><span class="built_in">Promise</span>的状态有哪些？</span><br><span class="line">	<span class="number">1.</span>pending进行中，<span class="number">2.</span>fulfilled/resolved -成功 <span class="number">3.</span>rejected-失败</span><br><span class="line">	<span class="built_in">Promise</span>对象代表一个异步操作，只有异步操作的结果，可以决定当前是哪一种状态，除此之外任何的操作都无法改变这个状态。</span><br><span class="line">	<span class="built_in">Promise</span>原型上还有then(),<span class="keyword">catch</span>(),all(),race()等方法；</span><br><span class="line">	then()是成功之后执行的一个方法；有两个参数，第一个参数是成功之后执行的，第二个是失败之后执行的；</span><br><span class="line">	<span class="keyword">catch</span>()是失败后执行，可以捕获异常；</span><br><span class="line">	all()方法是在处理多个异步处理时非常有用，就是调用多个promise回调成功之后的统一处理；</span><br><span class="line">	race()方法在处理数据的时候，哪个结果获得的快，就返回哪个，不管结果本身是成功还是失败。可以用来测试多个接口的响应速度；</span><br><span class="line"><span class="built_in">Promise</span>怎么使用？</span><br><span class="line">	<span class="built_in">Promise</span>是一个构造函数，所以我们在使用的时候是通过<span class="keyword">new</span> <span class="built_in">Promise</span>来实例化，它里面有两个默认的参数，resolve和reject是早就封装在构造函数里面的方法。</span><br><span class="line">	函数里面可以加一些逻辑，用来判断，返回成功就执行resolve，返回失败就执行reject；resolve方法可以把promise的状态从pedding改为resolved,。<span class="built_in">Promise</span>有一个特性就是一旦改变</span><br><span class="line">	不会再变。所以只要变成resolved或者是rejected.那么他将不会再变。</span><br><span class="line">从本质来说，<span class="built_in">Promise</span>主要用来解决异步回调的回调嵌套过多，导致的地域回调问题，可以使用then链式方法捕获最后的结果，比如我们经常用的axios就是用的<span class="built_in">Promise</span>方式处理异步请求；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="14请写出在vue中使用promise封装api接口的思路"><a class="markdownIt-Anchor" href="#14请写出在vue中使用promise封装api接口的思路">#</a> 14. 请写出在 vue 中使用 Promise 封装 api 接口的思路</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>中封装了原生的XHR，vue中为我们提供了axios来进行数据的请求，在vue项目少的情况下使用，会很方便，简单；但是如果在vue项目多的情况下</span><br><span class="line">我们就需要在每一个vue项目中写axios请求，这样会比较繁琐并且比较消耗性能。所以我们需要对axios进行进一步的封装。</span><br><span class="line"><span class="number">1.</span>在src里面新建一个utils文件夹，在这个文件里边再放一个request.js文件，在这个文件里要做<span class="number">3</span>件事，第一件事就是引入axios;第二件事就是用axios创建一个实例化的空对象取名叫Server，</span><br><span class="line">通过Server设置请求拦截器(interceptors.request)和响应拦截器(interceptors.response)然后通过. use引入函数，请求拦截器就是当把数据发送出去，还没到达服务端的时候，拦截你的数据</span><br><span class="line">看是否合法；请求拦截器函数里面有两个函数一个叫config，这个函数就是axios，当resolved调用成功之后返回 <span class="keyword">return</span> config;;还有一个叫error，这个是rejected失败之后掉用的;</span><br><span class="line">失败之后返回<span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">第三件事就是设置响应拦截器：响应拦截器就是服务端响应回来，但是数据还没有到达我们客户端的时候；interceptors.response.use;他也有两个函数，一个就是成功之后的response(),这里边</span><br><span class="line">可以判断一下，如果status状态为<span class="number">200</span>的话就只返回一个data数据，否则的话就返回一个空字符串；这样可以节省很多代码；如果失败的话和请求拦截器一样返回<span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)错误；</span><br><span class="line"></span><br><span class="line">最后在封装好后，导出模板实例化对象；需要把Server给导出去<span class="keyword">export</span> <span class="keyword">default</span> Server;然后在main.js里面引入，<span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;../utils/server.js&#x27;</span></span><br><span class="line"><span class="built_in">Promise</span>封装api可以用来处理一些公共数据，提高了安全性；</span><br></pre></td></tr></table></figure>
<h2 id="15ajax是什么以及如何创建ajax"><a class="markdownIt-Anchor" href="#15ajax是什么以及如何创建ajax">#</a> 15.Ajax 是什么？以及如何创建 Ajax?</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">	Ajax是什么？</span><br><span class="line">	    ajax主要是用来实现客户端和服务端异步通信的效果，实现页面的局部刷新，ajax原生方式主要是通过XMLHttpRequest,ActiveObject(IE)对象来实现异步通信效果</span><br><span class="line">	ajax的优势在哪儿?</span><br><span class="line">	    <span class="number">1.</span>不需要插件的支持，可以直接被大多数主流的浏览器支持</span><br><span class="line">	    <span class="number">2.</span>提高web程序性能：传统模式是通过form表单，数据获取是通过页面刷新获取整页内容，ajax可以通过XMLHttpRequest对象向服务器请求数据；</span><br><span class="line">	    <span class="number">3.</span>提高了用户体验		<span class="number">4.</span>无须刷新页面即可获取数据</span><br><span class="line">	Ajax的应用场景</span><br><span class="line">		用户登录注册，检测用户数据是否重复</span><br><span class="line">		做城市选择，用到二级联动或者三级甚至更高时，可以使用Ajax;</span><br><span class="line">	如何创建Ajax？</span><br><span class="line">	    <span class="number">1.</span>创建一个对象，<span class="keyword">let</span> xhr=<span class="literal">null</span>,创建一个请求：XMLHttpRequest,ActiveObject();</span><br><span class="line">	    <span class="number">2.</span>使用open方法初始化请求：xhr.open(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;地址&#x27;</span>) 他第一个参数是请求数据的方式，第二个参数是请求的url地址</span><br><span class="line">	    <span class="number">3.</span>设置header头 ajax跨域不能设置header头：xhr.setRequestHeader()设置http头信息；</span><br><span class="line">	    <span class="number">4.</span>设置回调函数：xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">	    <span class="number">5.</span>通过send()发送请求</span><br><span class="line">	jq方式：通过$ajax(&#123;-</span><br><span class="line">			url:<span class="string">&#x27;地址&#x27;</span>，type:<span class="string">&#x27;get&#x27;</span>请求方式，<span class="keyword">async</span>: <span class="literal">true</span>,是否为异步，dataType:<span class="string">&#x27;json&#x27;</span>数据的类型，success:<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;成功之后的业务逻辑&#125;，error:<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;失败之后&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	XMLHttpRequest对象的常用方法和属性</span><br><span class="line">		方法：open()初始化	send()发送请求  setRequestHeader 设置请求头</span><br><span class="line">		属性：onreadystatechange：用于指定状态改变时触发的事件处理器   readyState:获取请求状态</span><br><span class="line">		          responseText 获取服务端响应内容    status:http状态码</span><br><span class="line">	常见的http状态码</span><br><span class="line">		<span class="number">200</span>:请求成功    <span class="number">301</span>请求资源移动到新的url地址   <span class="number">403</span>客户端请求无权限，服务器拒绝请求    <span class="number">404</span>找不到文件</span><br><span class="line">		<span class="number">500</span>服务内部错误，一般是服务端代码有问题    <span class="number">502</span>网关错误，服务端返回无效响应    <span class="number">503</span>服务器性能问题导致，无法处理客户端请求</span><br><span class="line"><span class="string">``</span><span class="string">`	</span></span><br><span class="line"><span class="string">## 16.Ajax请求的时候get和post区别？</span></span><br><span class="line"><span class="string">	get传递参数显示在url地址中，post参数通过http消息formdata发送给服务器</span></span><br><span class="line"><span class="string">	get提交的数据有长度限制，原因是特定的浏览器url有长度限制，而post请求一般没有长度限制</span></span><br><span class="line"><span class="string">	get方式请求的数据会被缓存起来，所以相对来说不太安全，post相对来说比较安全</span></span><br><span class="line"><span class="string">	同等条件下，get传输数据会比post快一些</span></span><br><span class="line"><span class="string">			</span></span><br><span class="line"><span class="string">## 17.什么是跨域和解决跨域的方法</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">	<span class="number">1.</span>同源策略</span><br><span class="line">	    要了解跨域就要先知道同源策略；同源策略是浏览器的一种约定，他是浏览器最核心也是最基本的安全功能，同源指的就是，同协议，同域名，同端口，</span><br><span class="line">	同源策略的目的就是限制不同源的<span class="built_in">document</span>或者脚本之间的相互访问，以免造成干扰和混乱。</span><br><span class="line">	<span class="number">2.</span>为什么会有同源策略</span><br><span class="line">	    如果没有了同源策略，浏览器的一些正常功能可能都会受到影响，因为ajax是很灵活的，他可以发任何的请求，如果没有同源策略的限制，那么只要你</span><br><span class="line">	构造好参数和请求路径你的请求想往哪发就往哪发，这样太不安全了，会导致各种数据泄露；有了同源策略，那就不能随意发送请求了。	</span><br><span class="line">	<span class="number">3.</span>跨域的发生和解决方式</span><br><span class="line">	    当一个请求url的协议，域名，端口，三者之间任意一个与当前页面的url不同即为跨域；</span><br><span class="line">	    跨域的解决方式常见的有三种</span><br><span class="line">	        <span class="number">1.</span>cros服务端操作：把当前请求地址加入可允许访问的header中  Access-Control-Allow-Oragin</span><br><span class="line">	        <span class="number">2.</span>vue中的代理方式</span><br><span class="line">	           在vue中使用axios也可以配置跨域，在/config/index.js中将里面的target设置为我们要访问的域名。也就是后台ip地址。</span><br><span class="line">		再把changeorigin:<span class="literal">true</span>,设置为<span class="literal">true</span>开启反向代理，在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样客户端和服务端进行数据的交互就不会有跨域问题</span><br><span class="line">		最后pathRiwrite&#123;<span class="string">&#x27;^/api&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;设置为空，这里理解成用<span class="string">&#x27;/api&#x27;</span>代替target里面的地址</span><br><span class="line">	        <span class="number">3.</span>jsonp是服务器与客户端跨源通信的方法。最大的特点就是简单适用，兼容性好，缺点是只支持get请求，不支持post请求；</span><br><span class="line">	           jsonp实现的原理：主要是利用动态创建script标签请求后端接口地址，然后传递callback参数，后端接收callback，后端再经过数据处理返回</span><br><span class="line">	           callback函数调用的形式，callback中的参数就是json；</span><br><span class="line">	           jsonp使用场景：在jquery的api接口中使用，dataType设置为jsonp，也可以在script标签中通过src调用，需要传递callback回调函数</span><br><span class="line">				还可以在vue-resource插件中<span class="string">`this.$http.jsonp(&#x27;url&#x27;,&#123;&#125;).then(res=&gt;&#123;&#125;)`</span></span><br><span class="line">	           ajax的核心是通过XMLHttpRequest获取非本页内容，jsonp的核心是通过script标签来调用服务器提供的js脚本；</span><br><span class="line">		jsonp只支持get请求，而ajax支持get和post请求</span><br><span class="line"><span class="string">``</span><span class="string">`		</span></span><br><span class="line"><span class="string">## 18.vue中methods,computed,watch的区别</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">	首先就是这三个都是以函数为基础的，但他们却都不相同；</span><br><span class="line">	computed：他是当页面中有某些数据依赖于其他数据的变化进行改变的时候，可以使用computed的计算属性，计算属性具有缓存性；</span><br><span class="line">		computed是在HTML，DOM加载后马上执行的，比如赋值操作；</span><br><span class="line">		在需要对很多的数据进行处理和计算并且有另一个值需要依赖这个数据进行变化的时候就需要计算属性；</span><br><span class="line">	watch：watch和computed很相似，watch是用来观察和监听页面上的vue实例，在大部分情况下我们还是会使用computed，但如果要在数据变化</span><br><span class="line">		的同时进行异步操作的时候，warch是比较合适的选择。watch作为一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是</span><br><span class="line">		方法名；</span><br><span class="line">		如果在data中没有相应的属性的话，是不能使用watch的。</span><br><span class="line">		watch有一个特点，就是当值第一次改变的时候不会执行监听函数的。如果我们需要在最初绑定值的时候也</span><br><span class="line">		执行函数就需要用到immediate属性；就需要将immediate设为<span class="literal">true</span>;为<span class="literal">true</span>的时候就会立马执行handler方法，这个是vue规定的写法，当watch的值发生变化的时候就会触发；</span><br><span class="line">		deep属性：当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，只有data中的数据才能监听到变化时，</span><br><span class="line">			就需要deep属性对对象进行深度监听；</span><br><span class="line">	methods：methods是应用于逻辑和方法的处理，只要调用就会重新执行一次，这个调用是需要有一定的触发条件，比如点击事件；</span><br><span class="line">		methods和computed最大的区别就是computed依赖于data中的数据，而方法不依赖；这个依赖就是如果data中的数据发生变化，computed</span><br><span class="line">		会根据函数里面包含的计算属性重新计算；</span><br><span class="line">	总结：他们的形式都是<span class="function"><span class="keyword">function</span>，而本质的话<span class="title">computed</span>依赖于<span class="title">data</span>中的数据；场景的话：<span class="title">methods</span>是应用于逻辑和方法的处理；其余两者都是监听</span></span><br><span class="line"><span class="function">		<span class="title">data</span>中的数据；写法上：<span class="title">methods</span>可以带参数和返回值，不过不是必须的是可有可无；<span class="title">computed</span>：必须携带返回值，不允许带参数；</span></span><br><span class="line"><span class="function">		<span class="title">watch</span>：不允许带参数和返回值；用法上：<span class="title">methods</span>：是使用一次调用一次；<span class="title">computed</span>：一次调用，可以看做<span class="title">data</span>；<span class="title">watch</span>：调用一次</span></span><br><span class="line"><span class="function">		永久使用；使用位置：<span class="title">methods</span>：在生明周期函数中使用；<span class="title">computed</span>：和<span class="title">data</span>一样可以在<span class="title">vue</span>标签</span>&#123;&#123;&#125;&#125;中使用；watch：一般在生命周期</span><br><span class="line">		函数或者在methods被其他方法调用；</span><br></pre></td></tr></table></figure>
<h2 id="19vue双向数据绑定原理"><a class="markdownIt-Anchor" href="#19vue双向数据绑定原理">#</a> 19.vue 双向数据绑定原理</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	vue的双向数据绑定原理是采用数据劫持结合发布者和订阅者模式的方式，再利用<span class="built_in">Object</span>.defineProperty()来劫持各个属性的setter,getter,在数据</span><br><span class="line">	变动时发布消息给订阅者，在触发相应的监听回调；</span><br><span class="line">	其实就是通过<span class="built_in">Object</span>.defineProperty()这个方法和里面的get()获取属性值和set()设置属性值这两个方法操作的；它里面有两个常用参数，第一个</span><br><span class="line">	参数就是定义的对象的名字；比如<span class="keyword">var</span> obj = &#123;&#125;，obj就是第一个参数，第二个参数是要定义或修改的属性的名称，比如要定义obj对象里的name属性；get是获取属性，set是修改属性；</span><br><span class="line">	实现过程：<span class="number">1.</span>实现一个监听器Observer,用来劫持并监听所有属性，如果有变动的，就通知订阅者。</span><br><span class="line">		<span class="number">2.</span>实现一个订阅者Wather,可以收到属性的变化通知并执行相应的函数，从而更新视图。</span><br><span class="line">		<span class="number">3.</span>实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始话相应的相应的订阅器</span><br><span class="line"><span class="string">``</span><span class="string">`	</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 20.prop 验证，和默认值</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">	props：会接受不同的数据类型和设置默认值 ；有六种数据类型：<span class="built_in">Number</span>,<span class="built_in">String</span>,<span class="built_in">Object</span>,<span class="built_in">Function</span>,<span class="built_in">Array</span>,<span class="built_in">Boolean</span>;</span><br><span class="line">	props数据是单项数据传递，父不影响子，子不影响父；而且不能在组件中直接修改prop传递的值，Vue会发出警报；</span><br><span class="line">	在vue中父子组件的关系可以总结为props向下传递，事件向上传递。父组件通过prop给子组件下发数据，子组件通过事件给父组件发送消息。</span><br><span class="line">	prop是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来就不会了。这是为了阻止子组件无意间修改了父组件的状态，避免了</span><br><span class="line">	应用的数据流变得难以理解。</span><br><span class="line">	解决办法：将想要更改的值，传递给父组件，在父组件中更改，在传递给子组件。</span><br><span class="line">	具体步骤：先将值传递给子组件，子组件props接收并使用，然后通过$emit广播一个事件给父组件，并将值传递给父组件，父组件接收子组件广播</span><br><span class="line">		过来的事件，并定义一个方法，在该方法中改变传递过来的值，父组件又会将值传递给子组件，这样就形成了一个闭环，问题就解决了。</span><br></pre></td></tr></table></figure>
<h2 id="21vue组件父子子父看兄弟通信"><a class="markdownIt-Anchor" href="#21vue组件父子子父看兄弟通信">#</a> 21.vue 组件父子，子父看，兄弟通信</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    vue中组件的引入是通过在父组件中使用<span class="keyword">import</span> &#123;Son&#125; <span class="keyword">from</span> 后面写入组件路径 ，然后在局部组件components中注册子组件标签名字；</span><br><span class="line">在父组件template标签中引入子组件的标签即可</span><br><span class="line">    父传子：是通过prop属性来进行的，现在父组件中的子组件标签上绑定一个自定义属性，用于绑定要传递的值；然后在子组件中使用prop属性进行</span><br><span class="line">	数据的接收，可直接使用；prop中可以对传递过来的数据进行数据类型验证，设置默认值等；接收完的数据直接在子组件中使用，不需要在data中定义；</span><br><span class="line">    子传父：子传父主要是通过事件绑定的方式完成，在子组件元素中绑定一个事件，触发事件后，在事件中使用$emit，里面有两个参数(自定义事件，传递的值)，</span><br><span class="line">	在父组件中的子组件标签上绑定一个自定义事件，事件名必须是$emit中的事件名，自定义事件调用父组件自己定义的函数；</span><br><span class="line">	最后给父组件的函数设置形参，形参中存储的就是子组件传递过来的值。采用事件传递方式</span><br><span class="line">    兄弟组件传值：有两种方式可以实现</span><br><span class="line">	一种是通过创建一个bus.js的文件，在这个文件里面导出一个空的vue对象，在需要传递值和接收值得两个组件中都引入bus.js文件，在</span><br><span class="line">	发布数据的组件中通过bus.$emit(定义的事件，值)来传递数据；在需要接收数据的组件中通过bus.$on(自定义事件，(data)=&gt;&#123;&#125;)接收</span><br><span class="line">	里面的data就是接收到的值；</span><br><span class="line">	第二种就是vuex的方法实现：在需要使用的组件中使用<span class="built_in">this</span>.$store.state对象就可以使用仓库中state里面的数据；所有组件都可以使用，	</span><br><span class="line">	   这样就完成了兄弟组件的传值；</span><br></pre></td></tr></table></figure>
<h2 id="22vue中的生命周期"><a class="markdownIt-Anchor" href="#22vue中的生命周期">#</a> 22.vue 中的生命周期</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">有八个生命周期</span><br><span class="line">beforeCreate(创建前)：这是数据创建完成之前，这个阶段实例的data,methods这些是都访问不到的</span><br><span class="line">Created(创建后)：数据加载完成，是最早能够获取数据的函数无法获取DOM节点，这个阶段已经完成了数据观测，属性和方法的运算，但是数据并没有</span><br><span class="line">	在DOM元素上进行渲染；可以从服务器获取一些初始化的数据，还有通过ajax向服务器发送一些数据。</span><br><span class="line">beforeMounted(挂载前)：数据加载完成之后，DOM加载完成之前，只是模板和数据进行结合，但是没有挂载到页面上，可以在这里进行数据的最后修改</span><br><span class="line">Mounted(挂载后)：DOM节点挂载完成之后，最早可以操作DOM的函数；可以完成模板中的html渲染到页面上。这里面可以进行ajax交互。可以进行axios</span><br><span class="line">	     数据请求；而且mounted只会执行一次；</span><br><span class="line">beforeUpdate(更新前)：在数据更新之前调用；会更新当前组件数据，但不会在页面渲染出来；</span><br><span class="line">Updated(更新后)：data数据改变的时候，影响到DOM的时候；在这里可以获取到最新的DOM结构；</span><br><span class="line">beforeDestroy(销毁前)：在实例销毁之前调用，这个时候实例还可以使用，在这里可以清除一些组件中的定时器和监听dom事件</span><br><span class="line">Destroy(销毁后)：实例化销毁的时候触发；所有的事件监听器都会被清除，这个函数在服务器端渲染期间不被调用；</span><br><span class="line">第一次加载页面只会触发前四个钩子函数；</span><br></pre></td></tr></table></figure>
<h2 id="23vue路由传参如何实现"><a class="markdownIt-Anchor" href="#23vue路由传参如何实现">#</a> 23.vue 路由传参如何实现</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">	有query和params两种传参</span><br><span class="line">	query分为视图导航模式：格式就是:to=<span class="string">&quot;/path&quot;</span>+参数列表，在router-link里边写</span><br><span class="line">		编程导航：是通过<span class="built_in">this</span>.$router.push(&#123;<span class="attr">path</span>:<span class="string">&#x27;路径+参数&#x27;</span>&#125;)，获取参数的时候是<span class="built_in">this</span>.$router.query.参数名</span><br><span class="line">	params传递参数动态路由导航：在路由中找到指定路由的path：在后面加/:id;</span><br><span class="line">		视图导航模式：在router-link标签上加:to后面拼接<span class="string">&quot;&#x27;/路由地址/&#x27;+item.id&quot;</span>来进行路由跳转并传参</span><br><span class="line">		编程导航模式：通过<span class="built_in">this</span>.$router.push(&#123;<span class="attr">name</span>:<span class="string">&#x27;Detail&#x27;</span>通过name属性来进行跳转&#125;,<span class="attr">params</span>:&#123;<span class="attr">id</span>:id&#125;)；获取参数就是：<span class="built_in">this</span>.$route.params.id;</span><br><span class="line">	区别：query要通过path来引入，params要通过name引入，接收参数都是一样的只不过一个是用.query一个是.params;</span><br><span class="line">		query是类似于我们ajax中的get传参，params是类型于post传参，就是query在浏览器地址中显示参数，后者不显示；</span><br><span class="line">		</span><br><span class="line">## 24.路由导航模式有几种，如何实现	</span><br><span class="line">	这个就是vue-router提供的导航守卫主要是用来通过跳转或取消的方式守卫导航。通俗的说就是一个拦截器；</span><br><span class="line">	钩子函数有几种参数：to：即将要进入的路由对象；<span class="keyword">from</span>：当前导航正要离开的路由；next：进行管道中的下一个钩子，必须调用，他里面的参数</span><br><span class="line">		为<span class="literal">false</span>就终止执行，为<span class="literal">true</span>的话就继续执行，里面是一个路由路径的话跳转至指定的路由；</span><br><span class="line">	分为全局守卫：有beforeEach、beforeResolve、afterEach(在路由实例对象注册使用)；</span><br><span class="line">		beforeEach(全局前置守卫)可以进行一个判断，比如让一些用户通过一些用户不通过；如果用户名字是想要通过的那个，就执行next()</span><br><span class="line">		如果不是就得注意一个问题，不能直接写next(指定路径)，因为那样会造成死循环，直接执行跳转的时候，又会触发beforeEach方法，这样</span><br><span class="line">		就成了一个死循环，所以要再加一个判断：就是判断如果要去的路由是指定路径的话执行next(),跳转到指定路径，<span class="keyword">else</span>的话还是跳转到</span><br><span class="line">		该路径，这样都是跳转到该路径，就不会造成死循环了；</span><br><span class="line">		beforeResolve(全局解析守卫)：和beforeEach类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件解析之后，解析</span><br><span class="line">		守卫就会被调用；</span><br><span class="line">		afterEach(全局后置钩子)：这个是全局后置钩子，他和守卫不同的是，这些钩子不会接受next函数也不会改变导航本身；</span><br><span class="line">	路由专属守卫：在配置路由的时候设置，他只有一个路由守卫beforeEnter；</span><br><span class="line">	组件内部守卫：有三个方法：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave(在组件属性中定义)</span><br><span class="line">		beforeRouteEnter在渲染该组件的对应路由被确认前调用；他不能获取组件实例<span class="built_in">this</span>因为当前守卫执行前，组件实例还没被创建，可以</span><br><span class="line">		通过传一个回调给next来访问组件实例，在导航被确认的时候执行回调，并把组件实例	作为回调方法的参数；</span><br><span class="line">		beforeRouteUpdate：在当前路由改变，该组件被复用时调用，这个可以访问组件实例<span class="built_in">this</span></span><br><span class="line">		beforeRouteLeave：导航离开该组件的对应路由时被调用，他也可使用组件实例<span class="built_in">this</span>；</span><br><span class="line"><span class="string">``</span><span class="string">`			</span></span><br><span class="line"><span class="string">## 25.vuex 中 state,getters,mutations,actions,modules的用途和用法</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">	state 数据源载体，保存着所有的全局变量</span><br><span class="line">	getters 用于改变state的值，对state中的数据派生出一些状态，例如对数据进行过滤。会对state中的变量进行过滤再保存，只要state中的变量发生了改变，它也会</span><br><span class="line">		发生改变，不变化的时候，使用的是缓存。</span><br><span class="line">	mutation 唯一可以提交可以改变state的状态，也就是数据的属性值，他是通过直接改变状态的方式改变state，而且mutation必须同步执行，mutations相当于生成了修改全局</span><br><span class="line">		变量的事件函数，所以触发的时候需要事件驱动。因为他返回的是promise所以他是一个异步操作；</span><br><span class="line">	actions 他类似于mutation，不同就在于Action提交的是mutation，而不是直接变更状态。Action可以包含任意的异步操作；</span><br><span class="line">		Action他接受一个与store实例具有相同方法和属性的context对象，里面有commit方法和state属性等；触发action通过store.dispatch方法触发；</span><br><span class="line">	modules 由于使用单一状态树，应用的状态会集中到一个比较大的对象。当应用变得非常复杂的时候，store对象就有可能变得相当臃肿。为解决这个问题，vuex允许</span><br><span class="line">		我们将store分割成模块也就是Module，每个模块拥有自己的state,mutation,action,getter。甚至是嵌套子模块；需要注意的是modules模块中的state不能通过</span><br><span class="line">		<span class="built_in">this</span>.store.state获取，必须加上<span class="built_in">module</span>的命名空间；但是getters和mutations能正常使用；</span><br><span class="line">	总结：state中的状态数据，只能通过Mutation来修改；getters是来获取state中的数据，只会读取；</span><br><span class="line">	          actions是处理mutation的；modules是来分模块处理全局状态的；</span><br><span class="line">		mapState,mapGetters是来获取全局变量的，作为计算属性处理；</span><br><span class="line">		mapMutations,mapActions相当于事件处理函数，放在methods中，等待触发；</span><br><span class="line">		mapState,mapGetters,mapMutations,mapActions后面可以是对象，也可以是数组，数组里放原方法或属性名；对象，或者自己定义新的方法或属性名；</span><br></pre></td></tr></table></figure>
<h2 id="26vue-中-key-的作用"><a class="markdownIt-Anchor" href="#26vue-中-key-的作用">#</a> 26.vue 中 key 的作用</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	​在生成虚拟dom的过程中，相同的组件产生相同的dom结构，不同的组件产生不同的dom结构，同一层级的dom节点，他们可以通过唯一的id</span><br><span class="line">	进行区分，这个id就是key。</span><br><span class="line">	作用：高效的更新虚拟dom</span><br><span class="line"><span class="string">``</span><span class="string">`	</span></span><br><span class="line"><span class="string">## 27.vue 自定义指令如何使用</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">	很多时候我们需要直接操作 dom 元素，如果只是个别需要操作 dom 元素，我们可以通过 ref 获取当前 dom 元素，并对其进行操作，但是如果</span><br><span class="line">	特别多的时候，我们不可能每次都去写一遍 ref 还有方法，所以这时候自定义指令就可以帮你轻松解决这个问题</span><br><span class="line">	分为全局和局部;</span><br><span class="line">	钩子函数：</span><br><span class="line">		bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span><br><span class="line">		inserted：被绑定元素插入父节点时调用</span><br><span class="line">		update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。</span><br><span class="line">		componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</span><br><span class="line">		unbind：只调用一次，指令与元素解绑时调用。</span><br><span class="line">	钩子函数的参数：</span><br><span class="line">		**el**: 指令所绑定的元素，可以用来直接操作 DOM，就是放置指令的那个元素。</span><br><span class="line">		**binding**: 一个对象，里面包含了几个属性：value:指令的绑定值，name:指令名等；</span><br><span class="line">		**vnode**：Vue 编译生成的虚拟节点。</span><br><span class="line">		**oldVnode**：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</span><br></pre></td></tr></table></figure>
<h2 id="28vue-常用修饰符"><a class="markdownIt-Anchor" href="#28vue-常用修饰符">#</a> 28.vue 常用修饰符</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">事件修饰符：</span><br><span class="line">.prevent: 提交事件不再重载页面</span><br><span class="line">.stop: 阻止单击事件冒泡</span><br><span class="line">.self: 当事件发生在该元素本身而不是子元素的时候会触发</span><br><span class="line">.capture: 事件侦听，事件发生的时候会调用</span><br><span class="line">.once 只执行一次</span><br><span class="line">面试需要答的：</span><br><span class="line">.trim - 输入首尾空格过滤</span><br><span class="line">.number - 输入字符串转为有效的数字</span><br><span class="line">.lazy - 取代 input 监听 change 事件</span><br><span class="line">.passive：addEventListener中的第三个参数，表示 listener 永远不会调用 preventDefault()</span><br><span class="line">.native：组件绑定当前组件的事件是不会触发的，需要用native才能触发</span><br><span class="line">.sync：对prop进行双向绑定</span><br></pre></td></tr></table></figure>
<h2 id="29keep-alive-的作用"><a class="markdownIt-Anchor" href="#29keep-alive-的作用">#</a> 29.keep-alive 的作用</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">keep-alive是Vue中的内置组件，能在切换过程中把状态保留在内存中，防止重复渲染DOM</span><br><span class="line">包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</span><br><span class="line">prop:</span><br><span class="line">   		- include: 字符串或正则表达式。只有匹配的组件会被缓存。</span><br><span class="line">   		- exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。</span><br><span class="line">keep-alive生命周期钩子函数：activated、deactivated</span><br><span class="line">场景：Vue中前进刷新，后退缓存用户浏览数据</span><br><span class="line">	列表页面 =&gt;点击进入详情页=&gt; 后退到列表页 要缓存列表原来数据</span><br><span class="line">	重新进入列表页面 =&gt; 获取最新的数据</span><br></pre></td></tr></table></figure>
<h2 id="30什么是虚拟dom和-diff-算法"><a class="markdownIt-Anchor" href="#30什么是虚拟dom和-diff-算法">#</a> 30. 什么是虚拟 dom，和 diff 算法</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">什么是虚拟DOM</span><br><span class="line">       		可以把Virtual DOM 理解为一个简单的JS对象，并且最少包含标签名( tag)、属性(attrs)和子元素对象( children)三个属性。</span><br><span class="line">	将原本需要在真实dom进行的创建节点,删除节点,添加节点等一系列复杂的dom操作全部放到vdom中进行，这样就通过操作vdom来</span><br><span class="line">	提高直接操作的dom的效率和性能。</span><br><span class="line">	虚拟DOM的最终目标是将虚拟节点渲染到视图上</span><br><span class="line">	</span><br><span class="line">diff算法分为一下几个步骤</span><br><span class="line">       		- 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</span><br><span class="line">       		- 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</span><br><span class="line">       		- 把所记录的差异应用到所构建的真正的DOM树上，视图就更新了</span><br><span class="line"></span><br><span class="line">虚拟DOM就是对于复杂的文档DOM结构提供了一种方便的工具，用于最小化的dom操作本质上是通过JAVAScript来描述DOM之间的元素关系的；</span><br><span class="line">作用是能够更高效的渲染和更新视图实现原理是通过Dff算法来实现，就是比如当前页面的数据发生改变时，dff算法会比较同一层级的节点，如果节点类型不同，</span><br><span class="line">那么会直接干掉前面的节点，重新创建一个新节点，然后插入这个新节点，而不会再比较这个节点以后的子节点了，如果节点类型相同，那么会直接重新计算该节点的属性，对节点进行更新</span><br><span class="line">这就是dff的一个默认执行的操作，通常我们去渲染节点时，需要结合key属性来去使用，作为唯一标识，能够让dff正确识别当前节点，如果数据发生改变，或插入了新的节点时，</span><br><span class="line">这个时候dff算法就可以快速的找到当前需要修改的节点位置，去做视图更新，从而减少了dom重复的操作，大大地优化了网页性能</span><br></pre></td></tr></table></figure>
<h2 id="31图片懒加载"><a class="markdownIt-Anchor" href="#31图片懒加载">#</a> 31. 图片懒加载</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当打开一个有很多图片的页面时，先只加载页面上看到的图片，等滚动到页面下面时，再加载所需的图片。这就是图片懒加载。</span><br><span class="line">作用：减少或延迟请求数，缓解浏览器的压力，增强用户体验。</span><br><span class="line">实现方法：<span class="number">1</span>､设置图片src属性为同一张图片，同时自定义一个data-src属性来存储图片的真实地址</span><br><span class="line">	<span class="number">2</span>､ 页面初始化显示的时候或者浏览器发生滚动的时候判断图片是否在视野中</span><br><span class="line">	<span class="number">3</span>､ 当图片在视野中时，通过js自动改变该区域的图片的src属性为真实地址</span><br><span class="line"><span class="number">1.</span><span class="built_in">document</span>.documentElement.clientHeight获取屏幕可视窗口大小；</span><br><span class="line"><span class="number">2.</span><span class="built_in">document</span>.documentElement.scrollTop获取浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离</span><br><span class="line"> <span class="number">3.</span>判断当滚动条滚动到一定高度的时候就进行图片懒加载；</span><br></pre></td></tr></table></figure>
<h2 id="32瀑布流原理"><a class="markdownIt-Anchor" href="#32瀑布流原理">#</a> 32. 瀑布流原理</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">瀑布流的实现原理就是通过比较每一列的高度，如果这一列高度低的话就在这一列进行添加；</span><br><span class="line">实现步骤：<span class="number">1.</span>获取放图片的div和div里面的图片元素；</span><br><span class="line">	<span class="number">2.</span>通过<span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;在页面加载的时候执行定义的函数；</span><br><span class="line">	<span class="number">3.</span>定义一个变量columns计算出页面中有多少列=外层盒子的宽度box.offsetWidth/子元素的宽度items[<span class="number">0</span>].offsetWidth最后计算的时候用<span class="built_in">parseInt</span>除成整数</span><br><span class="line">	<span class="number">4.</span>循环所有的元素，在循环里面判断如果i小于columns的话就把每一项的top值设置为<span class="number">0</span>；把元素的left值设置为元素的宽度乘以下标值；然后在循环外面定义一个空数组</span><br><span class="line">		把每一项的高度都添加进去(items[i].offsetHeight)；然后就是i&gt;columns的逻辑，在这里面定义一个空变量为minHeight为最小高度，这个最小高度让他默认为<span class="number">0</span>；</span><br><span class="line">		在定义一个变量为Index为<span class="number">0</span>；然后在写一个循环，循环内容就是每个上面存储每一项高度的数组，然后再通过<span class="keyword">if</span>判断找出最小的高度值，逻辑就是如果当前循环的高度小于</span><br><span class="line">		上面定义的minHeight最小高度的话，就让minHeight等于这个高度，然后再让index等于这个元素的下标；</span><br><span class="line">	<span class="number">5.</span>最后一步就是把后面的元素插入到高度最小的元素下面，让循环的当前项的top值为最小高度，让他到这个元素的下面；left值为当前项距离外层盒子的Left值；</span><br></pre></td></tr></table></figure>
<h2 id="33从输入url到页面加载完成期间经历了什么"><a class="markdownIt-Anchor" href="#33从输入url到页面加载完成期间经历了什么">#</a> 33. 从输入 URL 到页面加载完成期间经历了什么？</h2>
<pre><code>1.通过DNS服务器：url=&gt;ip地址；
2.到达ip地址对应的服务器；
3.服务器接收用户的请求；
4.把处理后的结果返回给客户端；
5.客户端把结果渲染到浏览器即可，最后页面显示出来；
</code></pre>
<h2 id="34vue20和30区别"><a class="markdownIt-Anchor" href="#34vue20和30区别">#</a> 34.vue2.0 和 3.0 区别</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>默认进行懒观察　	</span><br><span class="line">	在 <span class="number">2.</span>x 版本里，不管数据多大，都会在一开始就为其创建观察者。当数据很大时，这可能会在页面载入时造成明显的性能压力。</span><br><span class="line">	<span class="number">3.</span>x 版本，只会对「被用于渲染初始可见部分的数据」创建观察者，而且 <span class="number">3.</span>x 的观察者更高效。</span><br><span class="line"><span class="number">2.</span>更精准的变更通知</span><br><span class="line">	比例来说：<span class="number">2.</span>x 版本中，使用 Vue.set 来给对象新增一个属性时，这个对象的所有 watcher 都会重新运行；<span class="number">3.</span>x 版本中，只有依赖那个属性的 watcher 才会重新运行。</span><br><span class="line"><span class="number">3.</span>  <span class="number">3.0</span> 新加入了 TypeScript 以及 PWA 的支持</span><br><span class="line"><span class="number">4.</span>部分命令发生了变化：<span class="number">4</span></span><br><span class="line">	<span class="number">1.</span>下载安装 npm install -g vue@cli	<span class="number">2.</span>删除了vue list	<span class="number">3.</span>创建项目 vue create	<span class="number">4.</span>启动项目 npm run serve</span><br><span class="line"><span class="number">5.</span>默认项目目录结构也发生了变化：</span><br><span class="line">	<span class="number">1.</span>移除了配置文件目录，config 和 build 文件夹</span><br><span class="line">	<span class="number">2.</span>移除了 <span class="keyword">static</span> 文件夹，新增 public 文件夹，并且 index.html 移动到 public 中</span><br><span class="line">	<span class="number">3.</span>在 src 文件夹中新增了 views 文件夹，用于分类 视图组件 和 公共组件</span><br></pre></td></tr></table></figure>
<h2 id="35react生命周期函数"><a class="markdownIt-Anchor" href="#35react生命周期函数">#</a> 35.react 生命周期函数</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">React的生命周期从广义上分为三个阶段：挂载，渲染，卸载；因此可以把React的生命周期分为两类：挂载，卸载过程和更新过程。</span><br><span class="line">挂载，卸载过程</span><br><span class="line"><span class="number">1.</span><span class="title">constructor</span>(<span class="params"></span>)：<span class="title">constructor</span>(<span class="params"></span>)完成了<span class="title">React</span>数据的初始化，他接受两个参数：<span class="title">props</span>和<span class="title">context</span>，当想在函数内部使用这两个参数的时候，需要使用<span class="title">super</span>(<span class="params"></span>)传入这两个参数；</span><br><span class="line">		需要注意的是只要使用了<span class="title">constructor</span>(<span class="params"></span>)就必须写<span class="title">super</span>(<span class="params"></span>)，否则会导致<span class="title">this</span>指向错误；</span><br><span class="line">2.<span class="title">componentWillMount</span>(<span class="params"></span>)：这个一般用的比较少，他更多的是在服务端渲染时使用。他代表的过程是组件已经经历<span class="title">constructor</span>(<span class="params"></span>)初始化数据后，但是还未渲染<span class="title">DOM</span>时。</span><br><span class="line">3.<span class="title">componentDidMount</span>(<span class="params"></span>)：组件第一次渲染完成，此时<span class="title">DOM</span>节点已经生成，可以在这里调用<span class="title">Ajax</span>请求，返回数据<span class="title">setState</span>后组件会重新渲染；</span><br><span class="line">4.<span class="title">componentWillUnmount</span>(<span class="params"></span>)：在这里完成组件的卸载和数据的销毁。会做2件事：(<span class="params"><span class="number">1</span></span>)：<span class="title">clear</span>清除你在组件中所有的<span class="title">setTimeout</span>，<span class="title">setInterval</span>；(<span class="params"><span class="number">2</span></span>)：移除所有组件中的监听：<span class="title">removeEventListener</span>;</span><br><span class="line">更新过程</span><br><span class="line"><span class="number">5.</span>componentWillReceiveProps(nextProps)：在接收父组件改变后的props需要重新渲染组件时用到的比较多；他会接收一个参数nextProps；通过对比nextProps和<span class="built_in">this</span>.props，将nextProps的state</span><br><span class="line">	作为当前组件的state，从而重新渲染组件；</span><br><span class="line"><span class="number">6.</span>shouldComponentUpdate(nextProps,nextState)：主要用于性能优化(部分更新)；唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的</span><br><span class="line">	流程，在这里<span class="keyword">return</span> <span class="literal">false</span>可以组织组件的更新；</span><br><span class="line"><span class="number">7.</span>componentWillUpdate(nextProps,nextState)：shouldComponentUpdate返回<span class="literal">true</span>以后，组件进入重新渲染的流程，进入componentWillUpdate，这里同样可以拿到nextProps和nextState。</span><br><span class="line"><span class="number">8.</span>componentDidUpdate(prevProps,prevState)：组件更新完毕以后，react只会在第一次初始化成功时进入componentDidmount,之后每次重新渲染都会重新进入这个生命周期，这里可以拿到</span><br><span class="line">	prevProps和prevState，也就是更新前的props和state;</span><br><span class="line"><span class="number">9.</span>render()：render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的</span><br><span class="line">	DOM节点，并重新渲染。</span><br></pre></td></tr></table></figure>
<h2 id="36类组件class-component和函数式组件functional-component之间有何不同"><a class="markdownIt-Anchor" href="#36类组件class-component和函数式组件functional-component之间有何不同">#</a> 36. 类组件 (Class component) 和函数式组件 (Functional component) 之间有何不同？</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数式组件又称无状态组件，无状态组件就是他没有自己的state状态管理，他只能接收父组件props传递过来的数据；无状态组件主要用来定义模板；</span><br><span class="line">Class组件又称有状态组件，他有自己的state状态管理，使用<span class="built_in">this</span>.state.数据的这种表达式把业务数据挂载到组件的实例上，然后传递props到展示组件，展示组件接收到props，把props放到模板里。</span><br><span class="line">   		类组件里面有一个<span class="title">constructor</span>(<span class="params"></span>)这个就是组件的构造方法，只要使用了他就必须使用<span class="title">super</span>(<span class="params"></span>),这个就是指向组件的构造方法；</span><br></pre></td></tr></table></figure>
<h2 id="37何为受控组件controlled-component"><a class="markdownIt-Anchor" href="#37何为受控组件controlled-component">#</a> 37. 何为受控组件 (controlled component)？</h2>
<pre><code>React组件的数据渲染是否被调用是通过传递过来的props完全控制，控制为受控组件，否则为非受控组件；例如：要实现利用父组件的数据控制子组件中内容的显示与隐藏；
</code></pre>
<h2 id="38generator异步编程-yield-next-await-async"><a class="markdownIt-Anchor" href="#38generator异步编程-yield-next-await-async">#</a> 38.generator（异步编程、yield、next ()、await 、async）</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Generator是一个函数，可以在函数内部通过<span class="keyword">yield</span>返回一个值（此时，Generator函数的执行会暂定，直到下次触发.next()）;</span><br><span class="line">使用流程：</span><br><span class="line"><span class="number">1.</span>创建一个Generator函数的方法是在<span class="function"><span class="keyword">function</span>关键字后添加*标识。</span></span><br><span class="line"><span class="function">2.在调用一个<span class="title">Generator</span>函数后，并不会立即执行其中的代码，函数会返回一个<span class="title">Generator</span>对象，通过调用对象的<span class="title">next</span>函数，可以获得<span class="title">yield</span>/<span class="title">return</span>的返回值。</span></span><br><span class="line"><span class="function">3.无论是触发了<span class="title">yield</span>还是<span class="title">return</span>，<span class="title">next</span>(<span class="params"></span>)函数总会返回一个带有<span class="title">value</span>和<span class="title">done</span>属性的对象。</span></span><br><span class="line"><span class="function">4.<span class="title">value</span>为返回值，<span class="title">done</span>则是一个<span class="title">Boolean</span>对象，用来标识<span class="title">Generator</span>是否还能继续提供返回值。</span></span><br><span class="line"><span class="function">需要注意的是：<span class="title">Generator</span>函数的执行时惰性的，<span class="title">yield</span>后的代码只在触发<span class="title">next</span>时才会执行；</span></span><br><span class="line"><span class="function"><span class="title">next</span>(<span class="params"></span>)我们可以在调用<span class="title">next</span>(<span class="params"></span>)的时候传递一个参数，可以在上次<span class="title">yield</span>前接收到这个参数：</span></span><br><span class="line"><span class="function">应用场景：1.因为<span class="title">Generator</span>对象是一个迭代器，所以我们可以直接用于<span class="title">for</span> <span class="title">of</span>循环；2.模拟实现<span class="title">Promise</span>执行器</span></span><br><span class="line"><span class="function"><span class="title">async</span> <span class="title">await</span></span></span><br><span class="line"><span class="function">	<span class="title">async</span> 是 <span class="title">ES7</span> 才有的与异步操作有关的关键字,在定义函数的时候在函数的前面加上<span class="title">async</span> 函数返回的是<span class="title">promise</span></span></span><br><span class="line"><span class="function">	<span class="title">await</span> 操作符用于等待一个 <span class="title">Promise</span> 对象, 它只能在异步函数 <span class="title">async</span> <span class="function"><span class="keyword">function</span> 内部使用。也就是<span class="title">async</span>可以没有<span class="title">await</span>，但是<span class="title">await</span>必须要有<span class="title">async</span></span></span></span><br></pre></td></tr></table></figure>
<h2 id="39axios-拦截做过哪些"><a class="markdownIt-Anchor" href="#39axios-拦截做过哪些">#</a> 39.Axios 拦截做过哪些？</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。有几点优势：<span class="number">1.</span>可以从浏览器中创建 XMLHttpRequests  <span class="number">2.</span>从 node.js 创建 http 请求  <span class="number">3.</span>支持 <span class="built_in">Promise</span> API</span><br><span class="line">	<span class="number">4.</span>拦截请求和响应  <span class="number">5.</span>转换请求数据和响应数据  <span class="number">6.</span>自动转换 <span class="built_in">JSON</span> 数据；</span><br><span class="line">可以在请求或响应被 then 或 <span class="keyword">catch</span> 处理前拦截它们。可以为自定义 axios 实例添加拦截器；</span><br><span class="line">请求拦截可以用它做我们的loading 加载和数据的权限验证,包括我们所有的数据预加载也可以实现；</span><br><span class="line">响应拦截：axios 拦截可以配置公用地址，以及对于跨域问题解决</span><br></pre></td></tr></table></figure>
<h2 id="40meta-标签内属性及详解"><a class="markdownIt-Anchor" href="#40meta-标签内属性及详解">#</a> 40.meta 标签内属性及详解</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>keywords：用来告诉搜索引擎，你网页的关键字；</span><br><span class="line"><span class="number">2.</span>description：用来告诉搜索引擎，你网站的主要内容；</span><br><span class="line"><span class="number">3.</span>viewport：移动端的窗口：width=device-width宽度等于当前设备的宽度；initial-scale=<span class="number">1.0</span>初始缩放比例，默认为一倍；minimum-scale=<span class="number">1.0</span>/maximum-scale=<span class="number">1.0</span>最小/大缩放比例；</span><br><span class="line">			user-scalable=no是否允许用户缩放页面；</span><br><span class="line"><span class="number">4.</span>robot：用来告诉爬虫哪些页面需要索引，哪些页面不需要索引。属性值为content，content参数有all,index搜索引擎将索引此网页，follow继续通过此网页的链接索引；</span><br><span class="line">	none将忽略此网页；noindex	搜索引擎不索引此网页；nofollow搜索引擎不继续通过此网页的链接索引搜索其他的网页；</span><br><span class="line"><span class="number">5.</span>author用于标注网页作者；</span><br><span class="line"><span class="number">6.</span>generator网页制作软件；</span><br><span class="line"><span class="number">7.</span>copyright版权；</span><br><span class="line"><span class="number">8.</span>revist-after重访；</span><br><span class="line"><span class="number">9.</span>renderer他是为双核浏览器准备的，用于指定双核浏览器默认以何种方式渲染页面；</span><br><span class="line"><span class="number">10.</span>expires期限，可以设定网页的到期时间。一旦网页过期，必须到服务器上重新传输；</span><br><span class="line"><span class="number">11.</span>Pragma禁止浏览器从本地计算机的缓存中访问页面内容；</span><br><span class="line"><span class="number">12.</span>Refresh刷新，自动刷新并指向新页面；里面有个content=<span class="number">2</span>是指停留<span class="number">2</span>秒钟后自动刷新到URL网址；后面的分号是在秒数的前面和网址的后面；</span><br><span class="line"><span class="number">13.</span><span class="built_in">Set</span>-Cookie用于cookie的设定，如果网页过期，那么存盘的cookie将被删除；</span><br><span class="line"><span class="number">14.</span>Window-target显示窗口的设定，强制页面在当前窗口以独立页面显示；</span><br><span class="line"><span class="number">15.</span>content-Type显示字符集的设定，设定页面使用的字符集；</span><br><span class="line"><span class="number">16.</span>content-language显示语言的设定；</span><br><span class="line"><span class="number">17.</span>cache-control指定请求和响应遵循的缓存机制，</span><br></pre></td></tr></table></figure>
<h2 id="41对bfc规范块级格式化上下文block-formatting-context的理解"><a class="markdownIt-Anchor" href="#41对bfc规范块级格式化上下文block-formatting-context的理解">#</a> 41. 对 BFC 规范 (块级格式化上下文：block formatting context) 的理解？</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BFC 就是“块级格式化上下文”的意思,创建了 BFC 的元素就是一个独立的盒子,不过只有 Block-level box 可以参与创建 BFC, 它规定了内部的 Block-level Box 如何布局,</span><br><span class="line">并且与这个独立盒子里的布局不受外部影响,当然它也不会影响到外面的元素。</span><br><span class="line">BFC 有一下特性：</span><br><span class="line">	内部的 Box 会在垂直方向,从顶部开始一个接一个地放置。</span><br><span class="line">	Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生叠加,</span><br><span class="line">	每个元素的 margin box 的左边, 与包含块 border box 的左边相接触(对于从左往右的格式化,否则相反)。即使存在浮动也是如此。</span><br><span class="line">	BFC 的区域不会与 float box 叠加。</span><br><span class="line">触发条件：</span><br><span class="line">	float的值不为none（默认）</span><br><span class="line">	overflow的值不为visible（默认）</span><br><span class="line">	display的值为inline-block、table-cell、table-caption</span><br><span class="line">	position的值为absolute或fixed</span><br><span class="line">	BFC 就是页面上的一个隔离的独立容器,容器里面的子元素不会影响到外面的元素,反之亦然。</span><br><span class="line">   计算 BFC 的高度时,浮动元素也参与计算。</span><br></pre></td></tr></table></figure>
<h2 id="42objectdefineproperty方法有何作用"><a class="markdownIt-Anchor" href="#42objectdefineproperty方法有何作用">#</a> 42.Object.defineProperty () 方法有何作用？</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">作用：<span class="built_in">Object</span>.defineProperty方法会直接在对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。	</span><br><span class="line">	在vue中通过getter和setter函数来实现双向绑定；</span><br><span class="line">语法：他有三个参数object，propName，descriptor</span><br><span class="line">参数解释：object：要定义属性的对象，返回的也是；propName：要定义或修改的属性名称。</span><br><span class="line">	descriptor：要定义或修改的属性描述符</span><br><span class="line">	描述符：<span class="number">1.</span>value描述符：设置属性值，默认值为<span class="literal">undefined</span>。</span><br><span class="line">		<span class="number">2.</span>writable描述符：设置属性的值是否可写，默认值为<span class="literal">true</span>。</span><br><span class="line">		<span class="number">3.</span>enumerable枚举描述符：设置属性是否可枚举，就是是否使用<span class="keyword">for</span>/<span class="keyword">in</span>语句或<span class="built_in">Object</span>.keys()函数遍历访问，默认为<span class="literal">true</span>。</span><br><span class="line">     <span class="number">4.</span>configurable描述符：设置是否可配置属性特性，默认为<span class="literal">true</span>。如果为<span class="literal">false</span>，将无法删除该属性，不能够修改属性值，也不能修改属性的属性描述符。</span><br></pre></td></tr></table></figure>
<h2 id="43vue-中数组中的某个对象的属性发生变化视图不更新如何解决"><a class="markdownIt-Anchor" href="#43vue-中数组中的某个对象的属性发生变化视图不更新如何解决">#</a> 43.vue 中数组中的某个对象的属性发生变化，视图不更新如何解决？</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	这种情况分为两种</span><br><span class="line">	第一种是数组的值改变，在改变数组的值的时候使用索引值去更改某一项，这样视图不会实时更新，这种情况是因为直接通过索引去改变数组，vue对象监听不到他的变化，所以没有更新；</span><br><span class="line">		解决方法：使用vue的变异方法pop(),push(),shift(),unshift(),revese(),sort(),splice()等方法也会触发视图更新</span><br><span class="line">	第二种是改变了对象的某一项，但是其他依赖这个数据的视图没有更新，比如父组件和子组件公用一份数据，数据通过props传到子组件，在子组件中修改数据父组件中不会响应；</span><br><span class="line">		解决方法：<span class="number">1.</span>利用vue.set(object,key,val)：例：vue.set(vm.obj,<span class="string">&#x27;k1&#x27;</span>,<span class="string">&#x27;v1&#x27;</span>);</span><br><span class="line">			<span class="number">2.</span>利用<span class="built_in">Object</span>.assign(&#123;&#125;,<span class="built_in">this</span>.obj)创建新对象；如果是数组就把花括号改为中括号；</span><br><span class="line">			<span class="number">3.</span>先删除掉那一项，然后再使用set去添加；</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"># 扩展：	</span><br><span class="line">	<span class="number">1.</span>vue鉴权</span><br><span class="line">		vue鉴权一般就是指管理后台的权限验证，先从登录说，当用户登录成功后，服务端接口一般会给用户分配一个token用于校验用户是否登录，当用户进入管理后台页面</span><br><span class="line">		的时候，我们可以通过token获取当前登录用户的角色，以及当前用户可以访问的路由地址列表，我们可以把用户可以访问的地址列表存储在本地。</span><br><span class="line">		后台的鉴权可以从两方面处理，一部分就是用户进入后台后，根据用户可以访问的路由地址信息，渲染出左侧的菜单栏部分，这样的话就只能访问左侧二级菜单相关的页面。</span><br><span class="line">		但是用户可能不是通过左侧二级菜单访问，可能是直接在浏览器输入路由地址访问，这个时候我们就得考虑使用路由守卫，路由守卫中有一个to方法，可以获取用户即将要</span><br><span class="line">		的路由地址，用这个地址跟用户存储的可访问的路由地址进行比较如果在用户可访问的地址列表中，就执行next(<span class="literal">true</span>)，否则的话直接跳转到自定义的<span class="number">403</span>页面提示，提示</span><br><span class="line">		用户无权限访问当页面。</span><br></pre></td></tr></table></figure>
      <div class="tags">
          <a href="/tags/%E6%80%BB%E7%BB%93/" rel="tag"><i class="ic i-tag"></i> 总结</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2021-01-05 19:07:56" itemprop="dateModified" datetime="2021-01-05T19:07:56+08:00">2021-01-05</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="高祥 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="高祥 支付宝">
        <p>支付宝</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="高祥 贝宝">
        <p>贝宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>高祥君 <i class="ic i-at"><em>@</em></i>主人
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2100/03/09/%E9%9D%A2%E8%AF%95%E9%AB%98%E5%87%A0%E7%8E%87%E8%80%83%E7%9A%84%E9%A2%98/" title="面试高几率考的题">http://example.com/2100/03/09/面试高几率考的题/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2024/10/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%8E%88%E6%9D%83/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipesrnqv3j20zk0m8ava.jpg" title="微信小程序登录实现授权">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> 小程序</span>
  <h3>微信小程序登录实现授权</h3>
  </a>

    </div>
    <div class="item right">
    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text"> 1. 响应式布局如何实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2rem%E5%B8%83%E5%B1%80%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text"> 2.rem 布局原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-number">3.</span> <span class="toc-text"> 3. 数据类型判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">4.</span> <span class="toc-text"> 4. 原型和原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E9%97%AD%E5%8C%85"><span class="toc-number">5.</span> <span class="toc-text"> 5. 闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6js%E7%BB%A7%E6%89%BF"><span class="toc-number">6.</span> <span class="toc-text"> 6.js 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8h5%E5%92%8Ccss3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">7.</span> <span class="toc-text"> 8.h5 和 css3 的新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9sessionstoragelocalstoragecookie-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text"> 9.SessionStorage，LocalStorage，Cookie 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.</span> <span class="toc-text"> 10. 什么是深拷贝和浅拷贝，如何实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">10.</span> <span class="toc-text"> 11. 解构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12es6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E6%89%A9%E5%B1%95"><span class="toc-number">11.</span> <span class="toc-text"> 12.ES6 有哪些新扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13promise%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%E5%92%8C%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">12.</span> <span class="toc-text"> 13.promise 是什么？有哪些状态和参数？如何使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E8%AF%B7%E5%86%99%E5%87%BA%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8promise%E5%B0%81%E8%A3%85api%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">13.</span> <span class="toc-text"> 14. 请写出在 vue 中使用 Promise 封装 api 接口的思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15ajax%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAajax"><span class="toc-number">14.</span> <span class="toc-text"> 15.Ajax 是什么？以及如何创建 Ajax?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">15.</span> <span class="toc-text"> 19.vue 双向数据绑定原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21vue%E7%BB%84%E4%BB%B6%E7%88%B6%E5%AD%90%E5%AD%90%E7%88%B6%E7%9C%8B%E5%85%84%E5%BC%9F%E9%80%9A%E4%BF%A1"><span class="toc-number">16.</span> <span class="toc-text"> 21.vue 组件父子，子父看，兄弟通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22vue%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">17.</span> <span class="toc-text"> 22.vue 中的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23vue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">18.</span> <span class="toc-text"> 23.vue 路由传参如何实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26vue-%E4%B8%AD-key-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">19.</span> <span class="toc-text"> 26.vue 中 key 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28vue-%E5%B8%B8%E7%94%A8%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">20.</span> <span class="toc-text"> 28.vue 常用修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29keep-alive-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">21.</span> <span class="toc-text"> 29.keep-alive 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9Fdom%E5%92%8C-diff-%E7%AE%97%E6%B3%95"><span class="toc-number">22.</span> <span class="toc-text"> 30. 什么是虚拟 dom，和 diff 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">23.</span> <span class="toc-text"> 31. 图片懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E7%80%91%E5%B8%83%E6%B5%81%E5%8E%9F%E7%90%86"><span class="toc-number">24.</span> <span class="toc-text"> 32. 瀑布流原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E6%9C%9F%E9%97%B4%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">25.</span> <span class="toc-text"> 33. 从输入 URL 到页面加载完成期间经历了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34vue20%E5%92%8C30%E5%8C%BA%E5%88%AB"><span class="toc-number">26.</span> <span class="toc-text"> 34.vue2.0 和 3.0 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">27.</span> <span class="toc-text"> 35.react 生命周期函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E7%B1%BB%E7%BB%84%E4%BB%B6class-component%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6functional-component%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">28.</span> <span class="toc-text"> 36. 类组件 (Class component) 和函数式组件 (Functional component) 之间有何不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E4%BD%95%E4%B8%BA%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6controlled-component"><span class="toc-number">29.</span> <span class="toc-text"> 37. 何为受控组件 (controlled component)？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38generator%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-yield-next-await-async"><span class="toc-number">30.</span> <span class="toc-text"> 38.generator（异步编程、yield、next ()、await 、async）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39axios-%E6%8B%A6%E6%88%AA%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B"><span class="toc-number">31.</span> <span class="toc-text"> 39.Axios 拦截做过哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40meta-%E6%A0%87%E7%AD%BE%E5%86%85%E5%B1%9E%E6%80%A7%E5%8F%8A%E8%AF%A6%E8%A7%A3"><span class="toc-number">32.</span> <span class="toc-text"> 40.meta 标签内属性及详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E5%AF%B9bfc%E8%A7%84%E8%8C%83%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87block-formatting-context%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">33.</span> <span class="toc-text"> 41. 对 BFC 规范 (块级格式化上下文：block formatting context) 的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42objectdefineproperty%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%BD%9C%E7%94%A8"><span class="toc-number">34.</span> <span class="toc-text"> 42.Object.defineProperty () 方法有何作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43vue-%E4%B8%AD%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E8%A7%86%E5%9B%BE%E4%B8%8D%E6%9B%B4%E6%96%B0%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">35.</span> <span class="toc-text"> 43.vue 中数组中的某个对象的属性发生变化，视图不更新如何解决？</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/2005/10/09/Vue%E5%B8%B8%E7%94%A8%E5%90%84%E7%A7%8D%E6%8F%92%E4%BB%B6%E8%AF%A6%E7%BB%86%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/" rel="bookmark" title="Vue常用各种插件详细安装步骤（不收藏就找不到了！）">Vue常用各种插件详细安装步骤（不收藏就找不到了！）</a></li><li><a href="/2010/10/09/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" rel="bookmark" title="项目开发流程">项目开发流程</a></li><li><a href="/2014/10/09/Es6/" rel="bookmark" title="ES6(这是我见过写的最好的)!推荐">ES6(这是我见过写的最好的)!推荐</a></li><li><a href="/2016/10/09/canvas%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" rel="bookmark" title="canvas常用方法总结">canvas常用方法总结</a></li><li><a href="/2019/03/09/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="bookmark" title="移动端面试题">移动端面试题</a></li><li><a href="/2019/07/09/Jquery%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" rel="bookmark" title="jQuery常用方法总结（前端的必须好好看看）">jQuery常用方法总结（前端的必须好好看看）</a></li><li><a href="/2020/05/31/JavaScript%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" rel="bookmark" title="JavaScript常用方法总结（前端的必须好好看看）">JavaScript常用方法总结（前端的必须好好看看）</a></li><li class="active"><a href="/2100/03/09/%E9%9D%A2%E8%AF%95%E9%AB%98%E5%87%A0%E7%8E%87%E8%80%83%E7%9A%84%E9%A2%98/" rel="bookmark" title="面试高几率考的题">面试高几率考的题</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="高祥"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">高祥</p>
  <div class="description" itemprop="description">前端高级工程师欢迎你</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">31</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">6</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">13</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tLzIzMjE4NzM3NjI=" title="https:&#x2F;&#x2F;github.com&#x2F;2321873762"><i class="ic i-github"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span>
      <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span>
      <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span>
      <span class="exturl item email" data-url="bWFpbHRvOnlvdXJuYW1lQG1haWwuY29t" title="mailto:yourname@mail.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" title="分类于 小程序">小程序</a>
</div>

    <span><a href="/2008/06/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" title="微信小程序基本使用">微信小程序基本使用</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%80%BB%E7%BB%93/" title="分类于 总结">总结</a>
</div>

    <span><a href="/2020/05/31/JavaScript%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" title="JavaScript常用方法总结（前端的必须好好看看）">JavaScript常用方法总结（前端的必须好好看看）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%B8%B8%E7%94%A8/" title="分类于 常用">常用</a>
</div>

    <span><a href="/2017/10/09/formDate%E5%BA%8F%E5%88%97%E5%8C%96/" title="formDate序列化">formDate序列化</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" title="分类于 小程序">小程序</a>
</div>

    <span><a href="/2010/02/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2%E5%B7%A6%E5%8F%B3%E4%B8%8D%E4%BA%92%E7%9B%B8%E5%BD%B1%E5%93%8D/" title="小程序分类页面左右不互相影响">小程序分类页面左右不互相影响</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="分类于 服务器">服务器</a>
</div>

    <span><a href="/2018/10/09/ajax%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/" title="Ajax详细获取数据(不会的转行吧！)">Ajax详细获取数据(不会的转行吧！)</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%80%BB%E7%BB%93/" title="分类于 总结">总结</a>
</div>

    <span><a href="/2100/03/09/%E9%9D%A2%E8%AF%95%E9%AB%98%E5%87%A0%E7%8E%87%E8%80%83%E7%9A%84%E9%A2%98/" title="面试高几率考的题">面试高几率考的题</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%B8%B8%E7%94%A8/" title="分类于 常用">常用</a>
</div>

    <span><a href="/2018/05/20/%E9%80%89%E4%B8%AD%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/" title="选中删除操作">选中删除操作</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%80%BB%E7%BB%93/" title="分类于 总结">总结</a>
</div>

    <span><a href="/2019/07/09/Jquery%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" title="jQuery常用方法总结（前端的必须好好看看）">jQuery常用方法总结（前端的必须好好看看）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="分类于 服务器">服务器</a>
</div>

    <span><a href="/2016/07/05/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="小程序分类页面左右不互相影响">小程序分类页面左右不互相影响</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Vue/" title="分类于 Vue">Vue</a>
</div>

    <span><a href="/2015/10/09/element-ui%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E6%95%88%E6%9E%9C/" title="element-ui实现分页效果">element-ui实现分页效果</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2021</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">高祥 @ GX</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2100/03/09/面试高几率考的题/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,copyright: '复制成功，转载请遵守 高祥的 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
